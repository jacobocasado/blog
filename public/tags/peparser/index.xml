<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>Peparser on purpurina - a place for hacking</title>
    <link>http://localhost:1313/tags/peparser/</link>
    <description>Recent content in Peparser on purpurina - a place for hacking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>made by jaco with love</copyright>
    <lastBuildDate>Thu, 27 Mar 2025 20:53:30 +0100</lastBuildDate><atom:link href="http://localhost:1313/tags/peparser/index.xml" rel="self" type="application/rss+xml" /><icon>http://localhost:1313/logo.jpg</icon>
    
    
    <item>
      <title>PE parsing</title>
      <link>http://localhost:1313/posts/pe_parsing/</link>
      <pubDate>Thu, 27 Mar 2025 20:53:30 +0100</pubDate>
      
      <guid>http://localhost:1313/posts/pe_parsing/</guid>
      <description><![CDATA[<p>A random page with some information of the PE format file and its main headers.
Main usage: malware development and malware research.</p>
<h1 id="considerations">Considerations</h1>
<ul>
<li>RVA (<strong>Relative Virtual Address</strong>): Offset from Image Base. To obtain the absolute virtual address the calculation &ldquo;Image Base + RVA&rdquo; must be performed. Several PE sections include RVAs.</li>
<li>Check the <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format">official Microsoft documentation</a> if you want to know more! This is only a summary and my personal studies about the topic.</li>
</ul>
<h1 id="dos-header">DOS header</h1>
<ul>
<li><code>IMAGE_DOS_HEADER</code> structure definition from <code>winnt.h</code>.</li>
<li>First 64 bytes of the PE file.</li>
<li>Was very important in the MS-DOS era, right now it is not.</li>
<li>The actual Windows OS loader uses a field in this header to navigate to the <strong>new executable</strong> header , which is the header containing most of the needed information.</li>
<li>Kept in the binaries for compatibility purposes.</li>
</ul>
<p>We only want to know about the first and last members of this header:</p>
<ul>
<li><strong><code>e_magic</code>:</strong> First member of the DOS Header, it’s a WORD (2 bytes), and it&rsquo;s a called a magic number. It has a fixed value of <code>0x5A4D</code> or <code>MZ</code> in ASCII, and it serves as a signature that marks the file as an MS-DOS executable.</li>
<li><strong><code>e_lfanew</code>:</strong> This is the last member of the DOS header. This member is important to the PE loader on Windows systems because it tells the loader where to look for the <strong>new executable header</strong>. It is basically an &ldquo;offset&rdquo; pointer to the <strong>new executable header (from now on, called PE header).</strong></li>
</ul>
<p>This is what the old MS-DOS loader and the new Windows PE Loader do with this header:
<img src="/images/post_images/pe_parsing.png" alt=""></p>
<h1 id="dos-stub">DOS stub</h1>
<p>The DOS stub is a MS-DOS program that prints an error message saying that the executable is not compatible with DOS, and exists. This is not executed in the modern Windows OS. This is what gets executed when the program is loaded in MS-DOS.
If we copy the bytes of the DOS stub into IDA or any disassembler, we can see that the code routine is just to print the string and exit.</p>
<p><img src="/images/post_images/pe_parsing_1.png" alt=""></p>
<h1 id="nt-header-pe-headernew-executable-header">NT header (PE header/new executable header)</h1>
<p><code>IMAGE_NT_HEADERS</code>as defined in <code>winnt.h</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_IMAGE_NT_HEADERS64</span> {
</span></span><span style="display:flex;"><span>    DWORD Signature;
</span></span><span style="display:flex;"><span>    IMAGE_FILE_HEADER FileHeader;
</span></span><span style="display:flex;"><span>    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
</span></span><span style="display:flex;"><span>} IMAGE_NT_HEADERS64, <span style="color:#f92672">*</span>PIMAGE_NT_HEADERS64;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_IMAGE_NT_HEADERS</span> {
</span></span><span style="display:flex;"><span>    DWORD Signature;
</span></span><span style="display:flex;"><span>    IMAGE_FILE_HEADER FileHeader;
</span></span><span style="display:flex;"><span>    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
</span></span><span style="display:flex;"><span>} IMAGE_NT_HEADERS32, <span style="color:#f92672">*</span>PIMAGE_NT_HEADERS32;
</span></span></code></pre></div><p>There is one structure for 32-bit executables and other for 64-bit executables.
The optional header differs, as can be seen in the struct.</p>
<h2 id="signature">Signature</h2>
<p>Fixed value of <code>0x50450000</code> which translates to <code>PE\0\0</code> in ASCII. Again, another magic number inside the executable. This is used by the loader to know that it has reached the correct section after querying <strong><code>e_lfanew</code></strong> from the DOS header.</p>
<h2 id="file-header">File Header</h2>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header">Check the official microsoft docs for this struct here</a>.
Another struct that contains information about the PE file. Some of this information is relevant. Let&rsquo;s see the struct:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_IMAGE_FILE_HEADER</span> {
</span></span><span style="display:flex;"><span>    WORD    Machine;
</span></span><span style="display:flex;"><span>    WORD    NumberOfSections;
</span></span><span style="display:flex;"><span>    DWORD   TimeDateStamp;
</span></span><span style="display:flex;"><span>    DWORD   PointerToSymbolTable;
</span></span><span style="display:flex;"><span>    DWORD   NumberOfSymbols;
</span></span><span style="display:flex;"><span>    WORD    SizeOfOptionalHeader;
</span></span><span style="display:flex;"><span>    WORD    Characteristics;
</span></span><span style="display:flex;"><span>} IMAGE_FILE_HEADER, <span style="color:#f92672">*</span>PIMAGE_FILE_HEADER;
</span></span></code></pre></div><p>Details about the header:</p>
<ul>
<li><strong><code>Machine</code></strong>: Target architecture of the executable. Normally, these values <code>0x8864</code> for <code>AMD64</code> and <code>0x14c</code> for <code>i386</code> are the common ones. However, for a complete list of possible values you can check the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">official Microsoft documentation</a>. However, this value is often ignored by the <strong><code>Magic</code></strong> value in the Optional Header (we will see it later).</li>
<li><strong><code>NumberOfSections</code></strong>: Number of sections that the binary has (.data is a section, for example).</li>
<li><strong><code>TimeDateStamp</code></strong>: The unix timestamp that indicates when the file was created.</li>
<li><strong><code>PointerToSymbolTable</code></strong>: The offset of the symbol table, in bytes, or zero if no COFF symbol table exists. Normally set to zero as the table does not get included by the compiler.</li>
<li><strong><code>NumberOfSymbols</code></strong>: Number of symbols in the COFF symbol table (normally 0).</li>
<li><strong><code>SizeOfOptionalHeader</code></strong>: The size of the optional header in bytes (we will see that header later).</li>
<li><strong><code>Characteristics</code>:</strong> A flag that indicates the attributes of the file, these attributes can be things like the file being executable, the file being a system file and not a user program, and a lot of other things. A complete list of these flags can be found on the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">official Microsoft documentation</a>.</li>
</ul>
<h2 id="optional-header">Optional Header</h2>
<p>This can be very confusing, but this header, called the optional header, is one of the most important headers in the PE.
The PE loader looks for specific information from this header in order to load and run the executable.
<strong>It&rsquo;s called optional header as this header is not included in object files, but it is included in image files, as executables.</strong>
It doesn’t have a fixed size, that’s why the <code>IMAGE_FILE_HEADER.SizeOfOptionalHeader</code> member exists.</p>
<p>As mentioned earlier, there are two versions of the Optional Header, one for 32-bit executables and one for 64-bit executables.<br>
The two versions are different in two aspects:</p>
<ul>
<li><strong>The size of the structure itself (or the number of members defined within the structure):</strong> <code>IMAGE_OPTIONAL_HEADER32</code> has 31 members while <code>IMAGE_OPTIONAL_HEADER64</code> only has 30 members, that additional member in the 32-bit version is a DWORD named <code>BaseOfData</code> which holds an RVA of the beginning of the <code>data</code> section.</li>
<li><strong>The data type of some of the members:</strong> The following 5 members of the Optional Header structure are defined as <code>DWORD</code> in the 32-bit version and as <code>ULONGLONG</code> in the 64-bit version:
<ul>
<li><strong><code>ImageBase</code></strong></li>
<li><strong><code>SizeOfStackReserve</code></strong></li>
<li><strong><code>SizeOfStackCommit</code></strong></li>
<li><strong><code>SizeOfHeapReserve</code></strong></li>
<li><strong><code>SizeOfHeapCommit</code></strong></li>
</ul>
</li>
</ul>
<p>We will focus in the 64 bit struct, as most of the malware we will create and parse will be of this type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_IMAGE_OPTIONAL_HEADER64</span> {
</span></span><span style="display:flex;"><span>    WORD        Magic;
</span></span><span style="display:flex;"><span>    BYTE        MajorLinkerVersion;
</span></span><span style="display:flex;"><span>    BYTE        MinorLinkerVersion;
</span></span><span style="display:flex;"><span>    DWORD       SizeOfCode;
</span></span><span style="display:flex;"><span>    DWORD       SizeOfInitializedData;
</span></span><span style="display:flex;"><span>    DWORD       SizeOfUninitializedData;
</span></span><span style="display:flex;"><span>    DWORD       AddressOfEntryPoint;
</span></span><span style="display:flex;"><span>    DWORD       BaseOfCode;
</span></span><span style="display:flex;"><span>    ULONGLONG   ImageBase;
</span></span><span style="display:flex;"><span>    DWORD       SectionAlignment;
</span></span><span style="display:flex;"><span>    DWORD       FileAlignment;
</span></span><span style="display:flex;"><span>    WORD        MajorOperatingSystemVersion;
</span></span><span style="display:flex;"><span>    WORD        MinorOperatingSystemVersion;
</span></span><span style="display:flex;"><span>    WORD        MajorImageVersion;
</span></span><span style="display:flex;"><span>    WORD        MinorImageVersion;
</span></span><span style="display:flex;"><span>    WORD        MajorSubsystemVersion;
</span></span><span style="display:flex;"><span>    WORD        MinorSubsystemVersion;
</span></span><span style="display:flex;"><span>    DWORD       Win32VersionValue;
</span></span><span style="display:flex;"><span>    DWORD       SizeOfImage;
</span></span><span style="display:flex;"><span>    DWORD       SizeOfHeaders;
</span></span><span style="display:flex;"><span>    DWORD       CheckSum;
</span></span><span style="display:flex;"><span>    WORD        Subsystem;
</span></span><span style="display:flex;"><span>    WORD        DllCharacteristics;
</span></span><span style="display:flex;"><span>    ULONGLONG   SizeOfStackReserve;
</span></span><span style="display:flex;"><span>    ULONGLONG   SizeOfStackCommit;
</span></span><span style="display:flex;"><span>    ULONGLONG   SizeOfHeapReserve;
</span></span><span style="display:flex;"><span>    ULONGLONG   SizeOfHeapCommit;
</span></span><span style="display:flex;"><span>    DWORD       LoaderFlags;
</span></span><span style="display:flex;"><span>    DWORD       NumberOfRvaAndSizes;
</span></span><span style="display:flex;"><span>    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
</span></span><span style="display:flex;"><span>} IMAGE_OPTIONAL_HEADER64, <span style="color:#f92672">*</span>PIMAGE_OPTIONAL_HEADER64;
</span></span></code></pre></div><p>Let&rsquo;s talk about the elements (<a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-image-only">information gathered from the Official Microsoft docs</a>):</p>
<ul>
<li>
<p><strong><code>Magic</code>:</strong> The optional header magic number determines whether an image is a PE32 or PE32+ executable. The value of this field is what determines whether the executable is 32-bit or 64-bit, <code>IMAGE_FILE_HEADER.Machine</code> is ignored by the Windows PE loader:</p>
<ul>
<li><strong><code>0x10B</code>:</strong> Identifies the image as a <code>PE32</code> executable.</li>
<li><strong><code>0x20B</code>:</strong> Identifies the image as a <code>PE32+</code> executable.</li>
<li><strong><code>0x107</code></strong>: Identifies it as a ROM image.</li>
</ul>
</li>
<li>
<p><strong><code>MajorLinkerVersion</code> and <code>MinorLinkerVersion</code>:</strong> The linker major and minor version numbers.</p>
</li>
<li>
<p><strong><code>SizeOfCode</code>:</strong> This field holds the size of the code (<code>.text</code>) section, or the sum of all code sections if there are multiple sections.</p>
</li>
<li>
<p><strong><code>SizeOfInitializedData</code>:</strong> This field holds the size of the initialized data (<code>.data</code>) section, or the sum of all initialized data sections if there are multiple sections.</p>
</li>
<li>
<p><strong><code>SizeOfUninitializedData</code>:</strong> This field holds the size of the uninitialized data (<code>.bss</code>) section, or the sum of all uninitialized data sections if there are multiple sections.</p>
</li>
<li>
<p><strong><code>AddressOfEntryPoint</code>:</strong> An RVA of the entry point when the file is loaded into memory. For program images, this is the starting address. For device drivers, this is the address of the initialization function. An entry point is optional for DLLs. When no entry point is present, this field must be zero.</p>
</li>
<li>
<p><strong><code>BaseOfCode</code>:</strong> An RVA of the start of the code section when the file is loaded into memory.</p>
</li>
<li>
<p><strong><code>ImageBase</code>:</strong> This field holds the preferred address of the first byte of image when loaded into memory (the preferred base address), this value must be a multiple of 64K.</p>
<ul>
<li>Due to memory protections like ASLR, and a lot of other reasons, <strong>the address specified by this field is almost never used</strong>. In such case, the PE loader chooses an unused memory range to load the image into, loads the image in such address, and  starts the <strong>relocation</strong> process.</li>
<li>In the <strong>relocation process</strong>, the OS fixes the constant addresses within the PE to work with the new image base.</li>
<li>There’s a special section that holds information about places that will need fixing if relocation is needed, that section is called the relocation section (<code>.reloc</code>).</li>
</ul>
</li>
<li>
<p><strong><code>SectionAlignment</code>:</strong> The alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to FileAlignment. The default is the page size for the architecture.</p>
</li>
<li>
<p><strong><code>FileAlignment</code>:</strong> Similar to <code>SectionAligment</code> this field holds a value that gets used for section raw data alignment <strong>on disk</strong> (in bytes), if the size of the actual data in a section is less than the <code>FileAlignment</code> value, the rest of the chunk gets padded with zeroes to keep the alignment boundaries. The documentation states that this value should be a power of 2 between 512 and 64K, and if the value of <code>SectionAlignment</code> is less than the architecture’s page size then the sizes of <code>FileAlignment</code> and <code>SectionAlignment</code> must match.</p>
</li>
<li>
<p><strong><code>MajorOperatingSystemVersion</code>, <code>MinorOperatingSystemVersion</code>, <code>MajorImageVersion</code>, <code>MinorImageVersion</code>, <code>MajorSubsystemVersion</code> and <code>MinorSubsystemVersion</code>:</strong> These members of the structure specify the major version number of the required operating system, the minor version number of the required operating system, the major version number of the image, the minor version number of the image, the major version number of the subsystem and the minor version number of the subsystem respectively.</p>
</li>
<li>
<p><strong><code>Win32VersionValue</code>:</strong> A reserved field that the documentation says should be set to <code>0</code>.</p>
</li>
<li>
<p><strong><code>SizeOfImage:</code></strong> The size of the image file (in bytes), including all headers. It gets rounded up to a multiple of <code>SectionAlignment</code> because this value is used when loading the image into memory.</p>
</li>
<li>
<p><strong><code>SizeOfHeaders</code>:</strong> The combined size of the DOS stub, PE header (NT Headers), and section headers rounded up to a multiple of <code>FileAlignment</code>.</p>
</li>
<li>
<p><strong><code>CheckSum</code>:</strong> A checksum of the image file, it’s used to validate the image at load time.</p>
</li>
<li>
<p><strong><code>Subsystem</code>:</strong> This field specifies the Windows subsystem (if any) that is required to run the image, A complete list of the possible values of this field can be found on the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">official Microsoft documentation</a>.</p>
</li>
<li>
<p><strong><code>DLLCharacteristics</code>:</strong> This field defines some characteristics of the executable image file, like if it’s <code>NX</code> compatible and if it can be relocated at run time.</p>
<ul>
<li>Although it is called <code>DLLCharacteristics</code>, it exists within normal executable image files and it defines characteristics that can apply to normal executable files. Don&rsquo;t get confused by the name. A complete list of the possible flags for <code>DLLCharacteristics</code> can be found on the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">official Microsoft documentation</a>.</li>
</ul>
</li>
<li>
<p><strong><code>SizeOfStackReserve</code>, <code>SizeOfStackCommit</code>, <code>SizeOfHeapReserve</code> and <code>SizeOfHeapCommit</code>:</strong> These fields specify the size of the stack to reserve, the size of the stack to commit, the size of the local heap space to reserve and the size of the local heap space to commit respectively.</p>
</li>
<li>
<p><strong><code>LoaderFlags</code>:</strong> A reserved field that the documentation says should be set to <code>0</code>.</p>
</li>
<li>
<p><strong><code>NumberOfRvaAndSizes</code> :</strong> Size of the <code>DataDirectory</code> array.</p>
</li>
<li>
<p><strong><code>DataDirectory</code>:</strong> An array of <code>IMAGE_DATA_DIRECTORY</code> structures. This is the interesting section of the optional header.</p>
</li>
</ul>
<h3 id="data-directory">Data Directory</h3>
<p>The optional header field has an array of <code>IMAGE_DATA_DIRECTORY</code> called <code>DataDirectory</code>, with a maximum size of 16 entries (specifed by the constant <code>IMAGE_NUMBEROF_DIRECTORY_ENTRIES</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ___IMAGE_DATA_DIRECTORY DataDirectory[___IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
</span></span></code></pre></div><p>An <code>IMAGE_DATA_DIRETORY</code> structure is defines as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_IMAGE_DATA_DIRECTORY</span> {
</span></span><span style="display:flex;"><span>    DWORD   VirtualAddress;
</span></span><span style="display:flex;"><span>    DWORD   Size;
</span></span><span style="display:flex;"><span>} IMAGE_DATA_DIRECTORY, <span style="color:#f92672">*</span>PIMAGE_DATA_DIRECTORY;
</span></span></code></pre></div><p>It’s a very simple structure with only two members, first one being an RVA pointing to the start of that Data Directory and the second one being the size of that Data Directory.</p>
<p>But, what is a Data Directory?
A Data Directory is a piece of data located within one of the sections of the PE file.<br>
Data Directories contain useful information needed by the Windows loader.
An example of a very important directory is the <strong>Import Directory</strong>, a data directory that contains the list of external functions imported from other libraries.</p>
<p>Here’s a list of Data Directories defined in <code>winnt.h</code>. (Each one of these values represents an index in the DataDirectory array):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Directory Entries
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   </span><span style="color:#75715e">// Export Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   </span><span style="color:#75715e">// Import Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   </span><span style="color:#75715e">// Resource Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   </span><span style="color:#75715e">// Exception Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   </span><span style="color:#75715e">// Security Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   </span><span style="color:#75715e">// Base Relocation Table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   </span><span style="color:#75715e">// Debug Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   </span><span style="color:#75715e">// Architecture Specific Data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   </span><span style="color:#75715e">// RVA of GP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_TLS             9   </span><span style="color:#75715e">// TLS Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   </span><span style="color:#75715e">// Load Configuration Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   </span><span style="color:#75715e">// Bound Import Directory in headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_IAT            12   </span><span style="color:#75715e">// Import Address Table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   </span><span style="color:#75715e">// Delay Load Import Descriptors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   </span><span style="color:#75715e">// COM Runtime descriptor
</span></span></span></code></pre></div><p>So, for example, to access the Import Directory information we will have to:</p>
<ul>
<li>Parse the DOS header.</li>
<li>Get the e_lfanew variable of the DOS header to get the offset to the PE header.</li>
<li>Navigate to the optional header.</li>
<li>Get to the offset where the Data Directory array is.</li>
<li>Get the position 1 of such array.</li>
</ul>
<p>We will obtain a struct containing the RVA and the size of such Data Directory.
With that information, we can access such directory and parse it. <strong>Note that each directory will be parsed differently, depending on the information that it contains.</strong></p>
<p>Also note that there can be data directories with no information. If we take a look at the contents of <code>IMAGE_OPTIONAL_HEADER.DataDirectory</code> of an actual PE file, we might see entries where both fields are set to <code>0</code>:
<img src="/images/post_images/pe_parsing_2.png" alt=""></p>
<p><strong>Important: Data directories can be inside the sections (e.g, the Import Directory Table is usually inside the .idata or .rdata section)</strong>. So, we can say that after the NT header, there are the section headers.dI</p>
<h1 id="section-headers">Section headers</h1>
<p>After the PE header, the section headers are the following. They are the last headers in the PE.
A Section Header is a structure named <code>IMAGE_SECTION_HEADER</code> defined in <code>winnt.h</code> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_IMAGE_SECTION_HEADER</span> {
</span></span><span style="display:flex;"><span>    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>            DWORD   PhysicalAddress;
</span></span><span style="display:flex;"><span>            DWORD   VirtualSize;
</span></span><span style="display:flex;"><span>    } Misc;
</span></span><span style="display:flex;"><span>    DWORD   VirtualAddress;
</span></span><span style="display:flex;"><span>    DWORD   SizeOfRawData;
</span></span><span style="display:flex;"><span>    DWORD   PointerToRawData;
</span></span><span style="display:flex;"><span>    DWORD   PointerToRelocations;
</span></span><span style="display:flex;"><span>    DWORD   PointerToLinenumbers;
</span></span><span style="display:flex;"><span>    WORD    NumberOfRelocations;
</span></span><span style="display:flex;"><span>    WORD    NumberOfLinenumbers;
</span></span><span style="display:flex;"><span>    DWORD   Characteristics;
</span></span><span style="display:flex;"><span>} IMAGE_SECTION_HEADER, <span style="color:#f92672">*</span>PIMAGE_SECTION_HEADER;
</span></span></code></pre></div><p>There will be one section header for each of the sections in the PE. Remember that we can retrieve the name of the sections:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;[NT header][file header] number of sections: %u&#34;</span>, <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>PEFILE_NT_HEADERS.FileHeader.NumberOfSections);
</span></span></code></pre></div><p>These are the fields of a section header:</p>
<ul>
<li><strong><code>Name</code>:</strong>  A byte array of the size <code>IMAGE_SIZEOF_SHORT_NAME</code> that holds the name of the section.
<ul>
<li><code>IMAGE_SIZEOF_SHORT_NAME</code> has the value of <code>8</code> meaning that a section name can’t be longer than 8 characters.</li>
<li>For longer names the official documentation mentions a work-around by filling this field with an offset in the string table, <strong>however executable images do not use a string table so this limitation of 8 characters holds for executable images</strong>.</li>
</ul>
</li>
<li><strong><code>PhysicalAddress</code> or <code>VirtualSize</code>:</strong> A <code>union</code> variable defines multiple names for the same thing. This field contains the <strong>total size of the section when it’s loaded in memory</strong>.</li>
<li><strong><code>VirtualAddress</code>:</strong> The documentation states that for executable images this field holds the address of the first byte of the section relative to the image base when loaded in memory, and for object files it holds the address of the first byte of the section before relocation is applied.</li>
<li><strong><code>SizeOfRawData</code>:</strong> This field contains the size of the section on disk, it must be a multiple of <code>IMAGE_OPTIONAL_HEADER.FileAlignment</code>.  Note that this is the size ondisk, whereas <code>PhysicalAddress</code> or <code>VirtualSize</code> specifies the size once it&rsquo;s loaded in memory (the size can differ).</li>
<li><strong><code>PointerToRawData</code>:</strong> A pointer to the first page of the section within the file, for executable images it must be a multiple of <code>IMAGE_OPTIONAL_HEADER.FileAlignment</code>.</li>
<li><strong><code>PointerToRelocations</code>:</strong> A file pointer to the beginning of relocation entries for the section. It’s set to <code>0</code> for executable files.</li>
<li><strong><code>PointerToLineNumbers</code>:</strong> A file pointer to the beginning of COFF line-number entries for the section. It’s normally set to <code>0</code> because COFF debugging information is deprecated.</li>
<li><strong><code>NumberOfRelocations</code>:</strong> The number of relocation entries for the section, it’s normally set to <code>0</code> for executable images.</li>
<li><strong><code>NumberOfLinenumbers</code>:</strong> The number of COFF line-number entries for the section, it’s set to <code>0</code> because COFF debugging information is deprecated.</li>
<li><strong><code>Characteristics</code>:</strong> Flags that describe the characteristics of the section.
<ul>
<li>These characteristics are things like if the section contains executable code, contains initialized/uninitialized data, can be shared in memory.</li>
<li>A complete list of section characteristics flags can be found on the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">official Microsoft documentation</a>.</li>
</ul>
</li>
</ul>
<h2 id="raw-data-can--virtual-size">Raw Data can != Virtual size</h2>
<p><code>SizeOfRawData</code> and <code>VirtualSize</code> can be different, and this can happen for multiple of reasons.</p>
<p><code>SizeOfRawData</code> (the size on disk) must be a multiple of <code>IMAGE_OPTIONAL_HEADER.FileAlignment</code>.
If the raw data size is less than that such value, the rest gets padded to match a multiple of the alignment.
However, when the section is loaded into memory it doesn’t follow that alignment and only the actual size of the section is occupied.  In this case <code>SizeOfRawData</code> will be greater than <code>VirtualSize</code>.</p>
<p><strong>The opposite can happen as well.</strong></p>
<p>If the section contains uninitialized data, these data won’t be accounted for on disk, but when the section gets mapped into memory, the section will expand to reserve memory space for when the uninitialized data gets later initialized and used.<br>
This means that the section on disk will occupy less than it will do in memory, in this case <code>VirtualSize</code> will be greater than <code>SizeOfRawData</code>.</p>
<h1 id="sections">Sections</h1>
<p>Lastly, the PE has the contents of the sections (.text, .data, .rdata).
Some sections have special names that indicate their purpose, we’ll go over some of them, and a full list of these names can be found on the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">official Microsoft documentation</a> under the “Special Sections” section.</p>
<ul>
<li><strong><code>.text</code>:</strong> Contains the executable code of the program.</li>
<li><strong><code>.data</code>:</strong> Contains the initialized data.</li>
<li><strong><code>.bss</code>:</strong> Contains uninitialized data.</li>
<li><strong><code>.rdata</code>:</strong> Contains read-only initialized data.</li>
<li><strong><code>.edata</code>:</strong> Contains the export tables.</li>
<li><strong><code>.idata</code>:</strong> Contains the import tables.</li>
<li><strong><code>.reloc</code>:</strong> Contains image relocation information.</li>
<li><strong><code>.rsrc</code>:</strong> Contains resources used by the program, these include images, icons or even embedded binaries.</li>
<li><strong><code>.tls</code>:</strong> (<strong>T</strong>hread <strong>L</strong>ocal <strong>S</strong>torage), provides storage for every executing thread of the program.</li>
</ul>
<h1 id="import-table">Import table</h1>
<p>There is no rule that says that the import table must begin at the start of a section named <code>.idata</code>, but that’s how it is typically done, for reasons both traditional and practical.</p>
<p>The first field of the import table, VirtualAddress, is actually the RVA of the table. The RVA is the address of the table relative to the base address of the image when the table is loaded. The second field gives the size in bytes. The data directories, which form the last part of the optional header, are listed in the following table.</p>
<p>Note that the number of directories is not fixed. Before looking for a specific directory, check the NumberOfRvaAndSizes field in the optional header.</p>
<p>Also, do not assume that the RVAs in this table point to the beginning of a section or that the sections that contain specific tables have specific names.</p>
<p><img src="content/images/post_images/pe_parsing_3.png" alt=""></p>
<p><img src="content/images/post_images/pe_parsing_4.png" alt="">
If we navigate to the Section headers, we will see that the .rdata section will start before 2DC0C8:
<img src="content/images/post_images/pe_parsing_5.png" alt=""></p>
<p>But we can see that the import directory is not <strong>at the start of the section, but somewhere in the middle, as the .rdata section starts a bit before (0x26000) whereas the import directory starts at 0x2D0C8.</strong> The tool just says that the Import Directory is inside .rdata, but not at the start of it.</p>
<p>We need to translate the <code>Import Directory RVA</code> to the file offset - a place in the binary file where the DLL import information is stored. The way this can be achieved is by using the following formula:</p>
<p>Location of the Import Directory = imageBase + section.RawOffset + (importDirectory.RVA − section.VA)</p>
<p>Where:</p>
<ul>
<li><code>imageBase</code> is the start address of where the binary image is loaded</li>
<li><code>section.RawOffset</code> is the <code>Raw Address</code> value from the <code>.text</code> section</li>
<li><code>text.VA</code> is <code>Virtual Address</code> value from the <code>.text</code> section</li>
<li><code>importDirectory.RVA</code> is the <code>Import Directory RVA</code> value from <code>Data Directories</code> in <code>Optional Header</code>.</li>
</ul>
<p>Let&rsquo;s think how to obtain all the values:</p>
<ul>
<li><code>imageBase</code> in our case is 0 since the file is not loaded to memory and we are inspecting it on the disk.</li>
<li>Import table is located in a specific section of the binary. Since the binary is not loaded to disk, we need to know the file offset of the section that the import directory is in relation to the <code>imageBase</code>.</li>
<li><code>imageBase + text.RawOffset</code> gives us the file offset to the <code>.text</code> section - we need it, because remember - the import table is inside the <code>.text</code> section</li>
<li>Since <code>importDirectory.RVA</code>, as mentioned earlier, lives in a section, <code>importDirectory.RVA - text.VA</code> gives us the offset of the import table relative to the start of the <code>.text</code> section</li>
<li>We take the value of <code>importDirectory.RVA - text.VA</code> and add it to the <code>text.RawOffset</code> and we get the offset of the import table in the raw section data. <strong>After that, we can start parsing the Import Directory.</strong></li>
</ul>
<p>It consists of an array of <code>IMAGE_IMPORT_DESCRIPTOR</code> structures, each one of them is for a DLL.<br>
It doesn’t have a fixed size, so the last <code>IMAGE_IMPORT_DESCRIPTOR</code> of the array is zeroed-out (NULL-Padded) to indicate the end of the Import Directory Table.</p>
<p><code>IMAGE_IMPORT_DESCRIPTOR</code> is defined as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_IMAGE_IMPORT_DESCRIPTOR</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>        DWORD   Characteristics;
</span></span><span style="display:flex;"><span>        DWORD   OriginalFirstThunk;
</span></span><span style="display:flex;"><span>    } DUMMYUNIONNAME;
</span></span><span style="display:flex;"><span>    DWORD   TimeDateStamp;
</span></span><span style="display:flex;"><span>    DWORD   ForwarderChain;
</span></span><span style="display:flex;"><span>    DWORD   Name;
</span></span><span style="display:flex;"><span>    DWORD   FirstThunk;
</span></span><span style="display:flex;"><span>} IMAGE_IMPORT_DESCRIPTOR;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED <span style="color:#f92672">*</span>PIMAGE_IMPORT_DESCRIPTOR;
</span></span></code></pre></div><h2 id="get-dll-name">Get DLL name</h2>
<p>We need to get the <code>Name RVA</code> (name does not point to the name, but contains a RVA) to a file offset using the technique we used earlier to get the location of the DLL name string.
This time the formula we need to use is:</p>
<pre tabindex="0"><code>offset = imageBase + text.RawOffset + (nameRVA − section.VA)
</code></pre><p>Where <code>nameRVA</code> is <code>Name RVA</code> value for ADVAPI32.dll from the Import Directory and <code>text.VA</code> is the <code>Virtual Address</code> of the <code>.text</code> section.</p>
<h2 id="get-dll-import-address-table-imported-functions">Get DLL Import Address Table (imported functions)</h2>
<p>TBD</p>
]]></description>
      
    </item>
    
    
  </channel>
</rss>
